{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Quantum Machine Learning com Qiskit e MNIST"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# INSTALAÇÃO DAS DEPENDÊNCIAS\n",
    "!pip install qiskit qiskit-aer qiskit-machine-learning numpy matplotlib torch scikit-learn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import numpy as np\n",
    "import torch\n",
    "\n",
    "# Configuração de sementes para reprodutibilidade\n",
    "SEED = 42\n",
    "random.seed(SEED)\n",
    "np.random.seed(SEED)\n",
    "torch.manual_seed(SEED)\n",
    "torch.cuda.manual_seed_all(SEED)\n",
    "torch.backends.cudnn.deterministic = True\n",
    "torch.backends.cudnn.benchmark = False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from qiskit import QuantumCircuit, transpile\n",
    "from qiskit_aer import AerSimulator\n",
    "from qiskit.circuit.library import ZZFeatureMap, RealAmplitudes\n",
    "from qiskit.quantum_info import SparsePauliOp\n",
    "from qiskit.primitives import Estimator\n",
    "from qiskit_machine_learning.neural_networks import EstimatorQNN\n",
    "from qiskit_machine_learning.connectors import TorchConnector\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import os\n",
    "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Visualização de Estados Quânticos"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def show_figure(pict, index=0):\n",
    "    \"\"\"Mostra uma imagem a partir de um array numpy.\"\"\"\n",
    "    try:\n",
    "        pict = np.asarray(pict, dtype=np.float64).ravel()\n",
    "        if pict.max() > 0:\n",
    "            pict = pict / pict.max()\n",
    "        size = len(pict)\n",
    "        dim = int(np.ceil(np.sqrt(size)))\n",
    "        padded = np.zeros((dim * dim,))\n",
    "        padded[:size] = pict\n",
    "        plt.figure(figsize=(5,5))\n",
    "        plt.imshow(padded.reshape(dim, dim), cmap=\"Greys\")\n",
    "        plt.axis('off')\n",
    "        plt.title(f\"Imagem {index}\")\n",
    "        plt.show()\n",
    "    except Exception as e:\n",
    "        print(f\"Erro ao mostrar figura {index}: {str(e)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def show_state_figure(statevector, index=0):\n",
    "    \"\"\"Visualiza um estado quântico como uma imagem.\"\"\"\n",
    "    try:\n",
    "        if hasattr(statevector, 'data'):\n",
    "            statevector = statevector.data\n",
    "        statevector = np.asarray(statevector, dtype=np.complex128)\n",
    "        probs = np.abs(statevector) ** 2  # Probabilidades dos estados\n",
    "        \n",
    "        print(f\"\\nEstado Quântico {index}:\")\n",
    "        print(f\"Dimensão do vetor de estado: {len(statevector)}\")\n",
    "        print(f\"5 primeiros valores: {statevector[:5]}\")\n",
    "        print(f\"Soma das probabilidades: {np.sum(probs):.4f}\")\n",
    "        \n",
    "        if len(probs) < 784:\n",
    "            padded = np.zeros(784)\n",
    "            padded[:len(probs)] = probs\n",
    "            probs = padded\n",
    "        \n",
    "        show_figure(probs, index=index)\n",
    "    except Exception as e:\n",
    "        print(f\"Erro ao processar estado {index}: {str(e)}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Configuração do Simulador Quântico com Ruído"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from qiskit_aer import AerSimulator\n",
    "from qiskit_aer.noise import NoiseModel, depolarizing_error\n",
    "\n",
    "# Criar modelo de ruído\n",
    "noise_model = NoiseModel()\n",
    "\n",
    "# Adicionar erros de depolarização\n",
    "error_1q = depolarizing_error(0.01, 1)  # 1% de erro em portas de 1 qubit\n",
    "error_2q = depolarizing_error(0.02, 2)  # 2% de erro em portas de 2 qubits\n",
    "\n",
    "noise_model.add_all_qubit_quantum_error(error_1q, ['h','x','y','rx','ry','rz'])\n",
    "noise_model.add_all_qubit_quantum_error(error_2q, ['cx'])\n",
    "\n",
    "# Criar simulador com ruído\n",
    "simulator = AerSimulator(noise_model=noise_model, shots=1024)\n",
    "\n",
    "print(\"Simulador configurado com modelo de ruído:\")\n",
    "print(noise_model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Carregamento e Processamento dos Dados"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "path = \"base_test_mnist_784_f90/qasm/\"\n",
    "file_list = sorted(os.listdir(path))[:20]  # Pegar apenas os 20 primeiros arquivos para demonstração\n",
    "\n",
    "states = []\n",
    "labels = []\n",
    "\n",
    "print(f\"\\nProcessando {len(file_list)} arquivos QASM...\")\n",
    "\n",
    "for i, file_name in enumerate(file_list):\n",
    "    try:\n",
    "        full_path = os.path.join(path, file_name)\n",
    "        print(f\"\\nProcessando arquivo {i+1}: {file_name}\")\n",
    "        \n",
    "        with open(full_path) as f:\n",
    "            qasm = f.read()\n",
    "            qc = QuantumCircuit.from_qasm_str(qasm)\n",
    "            \n",
    "            print(f\"\\nCircuito original:\")\n",
    "            print(qc)\n",
    "            \n",
    "            qc.save_statevector()\n",
    "            compiled = transpile(qc, simulator)\n",
    "            \n",
    "            print(\"\\nCircuito compilado:\")\n",
    "            print(compiled)\n",
    "            \n",
    "            job = simulator.run(compiled)\n",
    "            result = job.result()\n",
    "            state = result.data(0)['statevector']\n",
    "            \n",
    "            # Visualizar o estado quântico\n",
    "            show_state_figure(state, index=i)\n",
    "            \n",
    "            # Extrair features (usando apenas as primeiras 4 dimensões para simplificar)\n",
    "            features = np.abs(state)**2\n",
    "            features = features[:4]\n",
    "            \n",
    "            states.append(features)\n",
    "            labels.append(0 if i < 10 else 1)  # Classes fictícias para demonstração\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Erro ao processar {file_name}: {str(e)}\")\n",
    "\n",
    "# Converter para tensores PyTorch\n",
    "X = torch.tensor(states, dtype=torch.float32)\n",
    "y = torch.tensor(labels, dtype=torch.float32).unsqueeze(1)\n",
    "\n",
    "print(\"\\nDados processados:\")\n",
    "print(f\"Formato de X: {X.shape}\")\n",
    "print(f\"Formato de y: {y.shape}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Configuração do Modelo Quântico"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "num_qubits = 4\n",
    "\n",
    "# Mapa de características quânticas\n",
    "feature_map = ZZFeatureMap(num_qubits)\n",
    "print(\"\\nFeature Map:\")\n",
    "print(feature_map.draw())\n",
    "\n",
    "# Ansatz (circuito parametrizado)\n",
    "ansatz = RealAmplitudes(num_qubits, reps=1)\n",
    "print(\"\\nAnsatz:\")\n",
    "print(ansatz.draw())\n",
    "\n",
    "# Observável para medição\n",
    "observable = SparsePauliOp(\"Z\" * num_qubits)\n",
    "print(f\"\\nObservável: {observable}\")\n",
    "\n",
    "# Construir circuito completo\n",
    "qc_base = QuantumCircuit(num_qubits)\n",
    "qc_base.compose(feature_map, inplace=True)\n",
    "qc_base.compose(ansatz, inplace=True)\n",
    "\n",
    "print(\"\\nCircuito Completo:\")\n",
    "print(qc_base.draw())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Criar QNN (Rede Neural Quântica)\n",
    "estimator = Estimator()\n",
    "\n",
    "qnn = EstimatorQNN(\n",
    "    circuit=qc_base,\n",
    "    input_params=feature_map.parameters,\n",
    "    weight_params=ansatz.parameters,\n",
    "    observables=observable,\n",
    "    estimator=estimator,\n",
    "    input_gradients=True\n",
    ")\n",
    "\n",
    "# Conectar ao PyTorch\n",
    "model = TorchConnector(qnn)\n",
    "\n",
    "print(\"\\nModelo criado com sucesso!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Treinamento do Modelo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Configuração do treinamento\n",
    "loss_func = nn.BCELoss()\n",
    "optimizer = optim.Adam(model.parameters(), lr=0.01)\n",
    "\n",
    "print(\"\\nINICIANDO TREINAMENTO VQC...\")\n",
    "\n",
    "for epoch in range(25):\n",
    "    model.train()\n",
    "    optimizer.zero_grad()\n",
    "    output = model(X)\n",
    "    loss = loss_func(torch.sigmoid(output.squeeze()), y.squeeze())\n",
    "    loss.backward()\n",
    "    optimizer.step()\n",
    "\n",
    "    if (epoch + 1) % 5 == 0:\n",
    "        print(f\"Epoch {epoch+1}: Loss = {loss.item():.4f}\")\n",
    "        \n",
    "        # Visualizar os pesos treinados\n",
    "        trained_weights = model.weight.detach().numpy()\n",
    "        print(f\"Pesos treinados: {trained_weights}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Avaliação do Modelo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"\\nCALCULANDO MÉTRICAS...\")\n",
    "\n",
    "with torch.no_grad():\n",
    "    preds = model(X)\n",
    "    y_pred = torch.sigmoid(preds).squeeze().round().detach().numpy()\n",
    "    y_true = y.squeeze().numpy()\n",
    "\n",
    "    y_pred = y_pred.astype(int)\n",
    "    y_true = y_true.astype(int)\n",
    "\n",
    "    accuracy = accuracy_score(y_true, y_pred)\n",
    "    precision = precision_score(y_true, y_pred)\n",
    "    recall = recall_score(y_true, y_pred)\n",
    "    f1 = f1_score(y_true, y_pred)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"\\nMÉTRICAS FINAIS:\")\n",
    "print(f\"Acurácia : {accuracy:.4f}\")\n",
    "print(f\"Precisão : {precision:.4f}\")\n",
    "print(f\"Recall   : {recall:.4f}\")\n",
    "print(f\"F1 Score : {f1:.4f}\")\n",
    "\n",
    "print(\"\\nResultados Detalhados:\")\n",
    "print(\"Entradas:\", X.numpy())\n",
    "print(\"Saídas Previstas:\", y_pred)\n",
    "print(\"Saídas Reais:    \", y_true)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Visualização do Circuito Treinado"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Criar circuito com os pesos treinados\n",
    "trained_weights = model.weight.detach().numpy()\n",
    "final_circuit = QuantumCircuit(num_qubits)\n",
    "final_circuit.compose(feature_map, inplace=True)\n",
    "final_circuit.compose(ansatz.assign_parameters(trained_weights), inplace=True)\n",
    "\n",
    "print(\"\\nCircuito Treinado Final:\")\n",
    "print(final_circuit.draw())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simular o circuito treinado e visualizar o estado final\n",
    "final_circuit.save_statevector()\n",
    "compiled_final = transpile(final_circuit, simulator)\n",
    "job_final = simulator.run(compiled_final)\n",
    "result_final = job_final.result()\n",
    "final_state = result_final.data(0)['statevector']\n",
    "\n",
    "print(\"\\nEstado Final do Circuito Treinado:\")\n",
    "show_state_figure(final_state, index=\"final\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}